/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "ServiceApi.h"

#include <thrift/lib/cpp/TApplicationException.h>

namespace actor { namespace cpp2 {

template <typename ProtocolIn_, typename ProtocolOut_>
void ServiceApiAsyncProcessor::_processInThread_actorMessage(std::unique_ptr<apache::thrift::ResponseChannel::Request> req, std::unique_ptr<folly::IOBuf> buf, std::unique_ptr<ProtocolIn_> iprot, apache::thrift::Cpp2RequestContext* ctx, apache::thrift::async::TEventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  auto pri = iface_->getprio_actorMessage(ctx);
  processInThread<ProtocolIn_, ProtocolOut_>(std::move(req), std::move(buf),std::move(iprot), ctx, eb, tm, pri, true, &ServiceApiAsyncProcessor::process_actorMessage<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void ServiceApiAsyncProcessor::process_actorMessage(std::unique_ptr<apache::thrift::ResponseChannel::Request> req, std::unique_ptr<folly::IOBuf> buf, std::unique_ptr<ProtocolIn_> iprot,apache::thrift::Cpp2RequestContext* ctx,apache::thrift::async::TEventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  ServiceApi_actorMessage_pargs args;
  std::unique_ptr< ::actor::cpp2::ActorMsgHeader> uarg_header(new  ::actor::cpp2::ActorMsgHeader());
  args.header = uarg_header.get();
  std::unique_ptr< ::actor::cpp2::ActorMsgBuffer> uarg_payload(new  ::actor::cpp2::ActorMsgBuffer());
  args.payload = uarg_payload.get();
  std::unique_ptr<apache::thrift::ContextStack> c(this->getContextStack(this->getServiceName(), "ServiceApi.actorMessage", ctx));
  try {
    deserializeRequest(args, buf.get(), iprot.get(), c.get());
  }
  catch (const std::exception& ex) {
    LOG(ERROR) << ex.what() << " in function noResponse";
    return;
  }
  std::unique_ptr<apache::thrift::HandlerCallbackBase> callback(new apache::thrift::HandlerCallbackBase(std::move(req), std::move(c), nullptr, nullptr, eb, tm, ctx));
  ctx->setStartedProcessing();
  iface_->async_tm_actorMessage(std::move(callback), std::move(uarg_header), std::move(uarg_payload));
}

template <typename Protocol_>
void ServiceApiAsyncClient::actorMessageT(Protocol_* prot, const apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const  ::actor::cpp2::ActorMsgHeader& header, const  ::actor::cpp2::ActorMsgBuffer& payload) {
  std::unique_ptr<apache::thrift::ContextStack> ctx = this->getContextStack(this->getServiceName(), "ServiceApi.actorMessage", connectionContext_.get());
  ServiceApi_actorMessage_pargs args;
  args.header = const_cast< ::actor::cpp2::ActorMsgHeader*>(&header);
  args.payload = const_cast< ::actor::cpp2::ActorMsgBuffer*>(&payload);
  size_t bufSize = args.serializedSizeZC(prot);
  bufSize += prot->serializedMessageSize("actorMessage");
  folly::IOBufQueue queue(folly::IOBufQueue::cacheChainLength());
  prot->setOutput(&queue, bufSize);
  auto guard = folly::makeGuard([&]{prot->setOutput(nullptr);});
  try {
    ctx->preWrite();
    prot->writeMessageBegin("actorMessage", apache::thrift::T_CALL, 0);
    args.write(prot);
    prot->writeMessageEnd();
    ::apache::thrift::SerializedMessage smsg;
    smsg.protocolType = prot->protocolType();
    smsg.buffer = queue.front();
    ctx->onWriteData(smsg);
    ctx->postWrite(queue.chainLength());
  } catch(apache::thrift::TException &ex) {
    ctx->handlerError();
    throw;
  }
  auto eb = this->channel_->getEventBase();
  if(!eb || eb->isInEventBaseThread()) {
    ctx->asyncComplete();
    this->channel_->sendOnewayRequest(rpcOptions, std::move(callback), std::move(ctx), queue.move());
  }
  else {
    auto mvCb = folly::makeMoveWrapper(std::move(callback));
    auto mvCtx = folly::makeMoveWrapper(std::move(ctx));
    auto mvBuf = folly::makeMoveWrapper(queue.move());
    eb->runInEventBaseThread([this, rpcOptions, mvCb, mvCtx, mvBuf] () mutable {
      (*mvCtx)->asyncComplete();
      this->channel_->sendOnewayRequest(rpcOptions, std::move(*mvCb), std::move(*mvCtx), std::move(*mvBuf));
    }
    );
  }
}

template <class Protocol_>
uint32_t ServiceApi_actorMessage_pargs::read(Protocol_* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using apache::thrift::TProtocolException;


  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    if (fid == std::numeric_limits<int16_t>::min()) {
      if (fname == "header") {
        fid = 1;
        ftype = apache::thrift::protocol::T_STRUCT;
      }
      else if (fname == "payload") {
        fid = 2;
        ftype = apache::thrift::protocol::T_STRING;
      }
    }
    switch (fid) {
      case 1:
      {
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += ::apache::thrift::Cpp2Ops<  ::actor::cpp2::ActorMsgHeader>::read(iprot, &(*const_cast< ::actor::cpp2::ActorMsgHeader*>(this->header)));
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2:
      {
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*const_cast< ::actor::cpp2::ActorMsgBuffer*>(this->payload)));
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      }
      default:
      {
        xfer += iprot->skip(ftype);
        break;
      }
    }
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t ServiceApi_actorMessage_pargs::serializedSize(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ServiceApi_actorMessage_pargs");
  xfer += prot_->serializedFieldSize("header", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::Cpp2Ops<  ::actor::cpp2::ActorMsgHeader>::serializedSize(prot_, &(*const_cast< ::actor::cpp2::ActorMsgHeader*>(this->header)));
  xfer += prot_->serializedFieldSize("payload", apache::thrift::protocol::T_STRING, 2);
  xfer += prot_->serializedSizeBinary((*const_cast< ::actor::cpp2::ActorMsgBuffer*>(this->payload)));
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ServiceApi_actorMessage_pargs::serializedSizeZC(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->serializedStructSize("ServiceApi_actorMessage_pargs");
  xfer += prot_->serializedFieldSize("header", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::Cpp2Ops<  ::actor::cpp2::ActorMsgHeader>::serializedSizeZC(prot_, &(*const_cast< ::actor::cpp2::ActorMsgHeader*>(this->header)));
  xfer += prot_->serializedFieldSize("payload", apache::thrift::protocol::T_STRING, 2);
  xfer += prot_->serializedSizeZCBinary((*const_cast< ::actor::cpp2::ActorMsgBuffer*>(this->payload)));
  xfer += prot_->serializedSizeStop();
  return xfer;
}

template <class Protocol_>
uint32_t ServiceApi_actorMessage_pargs::write(Protocol_* prot_) const {
  uint32_t xfer = 0;
  xfer += prot_->writeStructBegin("ServiceApi_actorMessage_pargs");
  xfer += prot_->writeFieldBegin("header", apache::thrift::protocol::T_STRUCT, 1);
  xfer += ::apache::thrift::Cpp2Ops<  ::actor::cpp2::ActorMsgHeader>::write(prot_, &(*const_cast< ::actor::cpp2::ActorMsgHeader*>(this->header)));
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldBegin("payload", apache::thrift::protocol::T_STRING, 2);
  xfer += prot_->writeBinary((*const_cast< ::actor::cpp2::ActorMsgBuffer*>(this->payload)));
  xfer += prot_->writeFieldEnd();
  xfer += prot_->writeFieldStop();
  xfer += prot_->writeStructEnd();
  return xfer;
}

}} // actor::cpp2
namespace apache { namespace thrift {

}} // apache::thrift