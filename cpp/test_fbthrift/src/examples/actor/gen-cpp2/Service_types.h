/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace actor { namespace cpp2 {

class ActorId;
class ActorMsgHeader;
class ReplicaGroupInfo;
class ReplicaRequestHeader;
class ActorInfo;
class Init;
class Other;
class GetActorRegistry;
class GetActorRegistryResp;
class UpdateActorRegistry;
class UpdateActorInfo;
class RegisterException;
class GroupAddVolume;
class GroupPutObject;
class GroupPutObjectResp;
class GroupGetObject;
class GroupGetObjectResp;

enum class Error {
  ERR_OK = 0,
  ERR_INVALID = 1
};

extern const std::map<Error, const char*> _Error_VALUES_TO_NAMES;
extern const std::map<const char*, Error, apache::thrift::ltstr> _Error_NAMES_TO_VALUES;

}} // actor::cpp2
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::actor::cpp2::Error>::findName( ::actor::cpp2::Error value);
template <> bool TEnumTraitsBase< ::actor::cpp2::Error>::findValue(const char* name,  ::actor::cpp2::Error* outValue);

template <> constexpr  ::actor::cpp2::Error TEnumTraits< ::actor::cpp2::Error>::min() {
  return  ::actor::cpp2::Error::ERR_OK;
}

template <> constexpr  ::actor::cpp2::Error TEnumTraits< ::actor::cpp2::Error>::max() {
  return  ::actor::cpp2::Error::ERR_INVALID;
}

}} // apache::thrift
namespace actor { namespace cpp2 {

typedef int32_t ActorSystemId;

typedef int32_t LocalActorId;

typedef int32_t ActorMsgTypeId;

typedef int32_t RequestId;

typedef folly::IOBuf ActorMsgBuffer;

typedef int32_t ReplicaId;

typedef std::unique_ptr<ReplicaGroupInfo> ReplicaGroupInfoptr;

class ActorId : private boost::totally_ordered<ActorId> {
 public:

  ActorId() :
      systemId(0),
      localId(0) {}
  // FragileConstructor for use in initialization lists only

  ActorId(apache::thrift::FragileConstructor,  ::actor::cpp2::ActorSystemId systemId__arg,  ::actor::cpp2::LocalActorId localId__arg) :
      systemId(std::move(systemId__arg)),
      localId(std::move(localId__arg)) {}

  ActorId(ActorId&&) = default;

  ActorId(const ActorId&) = default;

  ActorId& operator=(ActorId&&) = default;

  ActorId& operator=(const ActorId&) = default;
  void __clear();

  virtual ~ActorId() throw() {}

   ::actor::cpp2::ActorSystemId systemId;
   ::actor::cpp2::LocalActorId localId;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      systemId = false;
      localId = false;
    }

    bool systemId;
    bool localId;
  } __isset;
  bool operator==(const ActorId& rhs) const;
  bool operator < (const ActorId& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(ActorId& a, ActorId& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::ActorId>::clear( ::actor::cpp2::ActorId* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorId>::write(Protocol* proto, const  ::actor::cpp2::ActorId* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorId>::read(Protocol* proto,   ::actor::cpp2::ActorId* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorId>::serializedSize(Protocol* proto, const  ::actor::cpp2::ActorId* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorId>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::ActorId* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class ActorMsgHeader : private boost::totally_ordered<ActorMsgHeader> {
 public:

  ActorMsgHeader() :
      direction(0),
      typeId(0),
      requestId(0),
      status(0) {}
  // FragileConstructor for use in initialization lists only

  ActorMsgHeader(apache::thrift::FragileConstructor, int8_t direction__arg,  ::actor::cpp2::ActorMsgTypeId typeId__arg,  ::actor::cpp2::ActorId from__arg,  ::actor::cpp2::ActorId to__arg,  ::actor::cpp2::RequestId requestId__arg, int32_t status__arg) :
      direction(std::move(direction__arg)),
      typeId(std::move(typeId__arg)),
      from(std::move(from__arg)),
      to(std::move(to__arg)),
      requestId(std::move(requestId__arg)),
      status(std::move(status__arg)) {}

  ActorMsgHeader(ActorMsgHeader&&) = default;

  ActorMsgHeader(const ActorMsgHeader&) = default;

  ActorMsgHeader& operator=(ActorMsgHeader&&) = default;

  ActorMsgHeader& operator=(const ActorMsgHeader&) = default;
  void __clear();

  virtual ~ActorMsgHeader() throw() {}

  int8_t direction;
   ::actor::cpp2::ActorMsgTypeId typeId;
   ::actor::cpp2::ActorId from;
   ::actor::cpp2::ActorId to;
   ::actor::cpp2::RequestId requestId;
  int32_t status;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      direction = false;
      typeId = false;
      from = false;
      to = false;
      requestId = false;
      status = false;
    }

    bool direction;
    bool typeId;
    bool from;
    bool to;
    bool requestId;
    bool status;
  } __isset;
  bool operator==(const ActorMsgHeader& rhs) const;
  bool operator < (const ActorMsgHeader& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(ActorMsgHeader& a, ActorMsgHeader& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::ActorMsgHeader>::clear( ::actor::cpp2::ActorMsgHeader* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorMsgHeader>::write(Protocol* proto, const  ::actor::cpp2::ActorMsgHeader* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorMsgHeader>::read(Protocol* proto,   ::actor::cpp2::ActorMsgHeader* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorMsgHeader>::serializedSize(Protocol* proto, const  ::actor::cpp2::ActorMsgHeader* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorMsgHeader>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::ActorMsgHeader* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class ReplicaGroupInfo : private boost::totally_ordered<ReplicaGroupInfo> {
 public:

  ReplicaGroupInfo() :
      replicaId(0),
      version(0) {}
  // FragileConstructor for use in initialization lists only

  ReplicaGroupInfo(apache::thrift::FragileConstructor,  ::actor::cpp2::LocalActorId replicaId__arg, int32_t version__arg, std::vector< ::actor::cpp2::ActorSystemId> replicaServices__arg, std::vector< ::actor::cpp2::ActorSystemId> healthyServices__arg, std::vector< ::actor::cpp2::ActorSystemId> unhealthyServices__arg) :
      replicaId(std::move(replicaId__arg)),
      version(std::move(version__arg)),
      replicaServices(std::move(replicaServices__arg)),
      healthyServices(std::move(healthyServices__arg)),
      unhealthyServices(std::move(unhealthyServices__arg)) {}

  ReplicaGroupInfo(ReplicaGroupInfo&&) = default;

  ReplicaGroupInfo(const ReplicaGroupInfo&) = default;

  ReplicaGroupInfo& operator=(ReplicaGroupInfo&&) = default;

  ReplicaGroupInfo& operator=(const ReplicaGroupInfo&) = default;
  void __clear();

  virtual ~ReplicaGroupInfo() throw() {}

   ::actor::cpp2::LocalActorId replicaId;
  int32_t version;
  std::vector< ::actor::cpp2::ActorSystemId> replicaServices;
  std::vector< ::actor::cpp2::ActorSystemId> healthyServices;
  std::vector< ::actor::cpp2::ActorSystemId> unhealthyServices;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      replicaId = false;
      version = false;
      replicaServices = false;
      healthyServices = false;
      unhealthyServices = false;
    }

    bool replicaId;
    bool version;
    bool replicaServices;
    bool healthyServices;
    bool unhealthyServices;
  } __isset;
  bool operator==(const ReplicaGroupInfo& rhs) const;
  bool operator < (const ReplicaGroupInfo& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(ReplicaGroupInfo& a, ReplicaGroupInfo& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::ReplicaGroupInfo>::clear( ::actor::cpp2::ReplicaGroupInfo* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaGroupInfo>::write(Protocol* proto, const  ::actor::cpp2::ReplicaGroupInfo* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaGroupInfo>::read(Protocol* proto,   ::actor::cpp2::ReplicaGroupInfo* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaGroupInfo>::serializedSize(Protocol* proto, const  ::actor::cpp2::ReplicaGroupInfo* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaGroupInfo>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::ReplicaGroupInfo* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class ReplicaRequestHeader : private boost::totally_ordered<ReplicaRequestHeader> {
 public:

  ReplicaRequestHeader() :
      replicaId(0),
      version(0) {}
  // FragileConstructor for use in initialization lists only

  ReplicaRequestHeader(apache::thrift::FragileConstructor,  ::actor::cpp2::ActorMsgHeader actorHdr__arg,  ::actor::cpp2::ReplicaId replicaId__arg, int32_t version__arg) :
      actorHdr(std::move(actorHdr__arg)),
      replicaId(std::move(replicaId__arg)),
      version(std::move(version__arg)) {}

  ReplicaRequestHeader(ReplicaRequestHeader&&) = default;

  ReplicaRequestHeader(const ReplicaRequestHeader&) = default;

  ReplicaRequestHeader& operator=(ReplicaRequestHeader&&) = default;

  ReplicaRequestHeader& operator=(const ReplicaRequestHeader&) = default;
  void __clear();

  virtual ~ReplicaRequestHeader() throw() {}

   ::actor::cpp2::ActorMsgHeader actorHdr;
   ::actor::cpp2::ReplicaId replicaId;
  int32_t version;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      actorHdr = false;
      replicaId = false;
      version = false;
    }

    bool actorHdr;
    bool replicaId;
    bool version;
  } __isset;
  bool operator==(const ReplicaRequestHeader& rhs) const;
  bool operator < (const ReplicaRequestHeader& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(ReplicaRequestHeader& a, ReplicaRequestHeader& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::ReplicaRequestHeader>::clear( ::actor::cpp2::ReplicaRequestHeader* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaRequestHeader>::write(Protocol* proto, const  ::actor::cpp2::ReplicaRequestHeader* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaRequestHeader>::read(Protocol* proto,   ::actor::cpp2::ReplicaRequestHeader* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaRequestHeader>::serializedSize(Protocol* proto, const  ::actor::cpp2::ReplicaRequestHeader* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ReplicaRequestHeader>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::ReplicaRequestHeader* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class ActorInfo : private boost::totally_ordered<ActorInfo> {
 public:

  ActorInfo() :
      port(0),
      incarnation(0) {}
  // FragileConstructor for use in initialization lists only

  ActorInfo(apache::thrift::FragileConstructor, std::string type__arg,  ::actor::cpp2::ActorId id__arg, std::string ip__arg, int32_t port__arg, int32_t incarnation__arg) :
      type(std::move(type__arg)),
      id(std::move(id__arg)),
      ip(std::move(ip__arg)),
      port(std::move(port__arg)),
      incarnation(std::move(incarnation__arg)) {}

  ActorInfo(ActorInfo&&) = default;

  ActorInfo(const ActorInfo&) = default;

  ActorInfo& operator=(ActorInfo&&) = default;

  ActorInfo& operator=(const ActorInfo&) = default;
  void __clear();

  virtual ~ActorInfo() throw() {}

  std::string type;
   ::actor::cpp2::ActorId id;
  std::string ip;
  int32_t port;
  int32_t incarnation;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      type = false;
      id = false;
      ip = false;
      port = false;
      incarnation = false;
    }

    bool type;
    bool id;
    bool ip;
    bool port;
    bool incarnation;
  } __isset;
  bool operator==(const ActorInfo& rhs) const;
  bool operator < (const ActorInfo& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(ActorInfo& a, ActorInfo& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::ActorInfo>::clear( ::actor::cpp2::ActorInfo* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorInfo>::write(Protocol* proto, const  ::actor::cpp2::ActorInfo* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorInfo>::read(Protocol* proto,   ::actor::cpp2::ActorInfo* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorInfo>::serializedSize(Protocol* proto, const  ::actor::cpp2::ActorInfo* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::ActorInfo>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::ActorInfo* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class Init : private boost::totally_ordered<Init> {
 public:

  Init() {}
  // FragileConstructor for use in initialization lists only

  Init(apache::thrift::FragileConstructor) {}

  Init(Init&&) = default;

  Init(const Init&) = default;

  Init& operator=(Init&&) = default;

  Init& operator=(const Init&) = default;

  virtual ~Init() throw() {}

  bool operator==(const Init& /* rhs */) const;

  bool operator < (const Init& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Init& a, Init& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Init>::write(Protocol* proto, const  ::actor::cpp2::Init* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Init>::read(Protocol* proto,   ::actor::cpp2::Init* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Init>::serializedSize(Protocol* proto, const  ::actor::cpp2::Init* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Init>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::Init* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class Other : private boost::totally_ordered<Other> {
 public:

  Other() {}
  // FragileConstructor for use in initialization lists only

  Other(apache::thrift::FragileConstructor) {}

  Other(Other&&) = default;

  Other(const Other&) = default;

  Other& operator=(Other&&) = default;

  Other& operator=(const Other&) = default;

  virtual ~Other() throw() {}

  bool operator==(const Other& /* rhs */) const;

  bool operator < (const Other& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(Other& a, Other& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Other>::write(Protocol* proto, const  ::actor::cpp2::Other* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Other>::read(Protocol* proto,   ::actor::cpp2::Other* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Other>::serializedSize(Protocol* proto, const  ::actor::cpp2::Other* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::Other>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::Other* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GetActorRegistry : private boost::totally_ordered<GetActorRegistry> {
 public:

  GetActorRegistry() {}
  // FragileConstructor for use in initialization lists only

  GetActorRegistry(apache::thrift::FragileConstructor) {}

  GetActorRegistry(GetActorRegistry&&) = default;

  GetActorRegistry(const GetActorRegistry&) = default;

  GetActorRegistry& operator=(GetActorRegistry&&) = default;

  GetActorRegistry& operator=(const GetActorRegistry&) = default;

  virtual ~GetActorRegistry() throw() {}

  bool operator==(const GetActorRegistry& /* rhs */) const;

  bool operator < (const GetActorRegistry& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GetActorRegistry& a, GetActorRegistry& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistry>::write(Protocol* proto, const  ::actor::cpp2::GetActorRegistry* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistry>::read(Protocol* proto,   ::actor::cpp2::GetActorRegistry* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistry>::serializedSize(Protocol* proto, const  ::actor::cpp2::GetActorRegistry* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistry>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GetActorRegistry* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GetActorRegistryResp : private boost::totally_ordered<GetActorRegistryResp> {
 public:

  GetActorRegistryResp() {}
  // FragileConstructor for use in initialization lists only

  GetActorRegistryResp(apache::thrift::FragileConstructor, std::vector< ::actor::cpp2::ActorInfo> infoList__arg) :
      infoList(std::move(infoList__arg)) {}

  GetActorRegistryResp(GetActorRegistryResp&&) = default;

  GetActorRegistryResp(const GetActorRegistryResp&) = default;

  GetActorRegistryResp& operator=(GetActorRegistryResp&&) = default;

  GetActorRegistryResp& operator=(const GetActorRegistryResp&) = default;
  void __clear();

  virtual ~GetActorRegistryResp() throw() {}

  std::vector< ::actor::cpp2::ActorInfo> infoList;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      infoList = false;
    }

    bool infoList;
  } __isset;
  bool operator==(const GetActorRegistryResp& rhs) const;
  bool operator < (const GetActorRegistryResp& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GetActorRegistryResp& a, GetActorRegistryResp& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::GetActorRegistryResp>::clear( ::actor::cpp2::GetActorRegistryResp* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistryResp>::write(Protocol* proto, const  ::actor::cpp2::GetActorRegistryResp* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistryResp>::read(Protocol* proto,   ::actor::cpp2::GetActorRegistryResp* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistryResp>::serializedSize(Protocol* proto, const  ::actor::cpp2::GetActorRegistryResp* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GetActorRegistryResp>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GetActorRegistryResp* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class UpdateActorRegistry : private boost::totally_ordered<UpdateActorRegistry> {
 public:

  UpdateActorRegistry() {}
  // FragileConstructor for use in initialization lists only

  UpdateActorRegistry(apache::thrift::FragileConstructor) {}

  UpdateActorRegistry(UpdateActorRegistry&&) = default;

  UpdateActorRegistry(const UpdateActorRegistry&) = default;

  UpdateActorRegistry& operator=(UpdateActorRegistry&&) = default;

  UpdateActorRegistry& operator=(const UpdateActorRegistry&) = default;

  virtual ~UpdateActorRegistry() throw() {}

  bool operator==(const UpdateActorRegistry& /* rhs */) const;

  bool operator < (const UpdateActorRegistry& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(UpdateActorRegistry& a, UpdateActorRegistry& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorRegistry>::write(Protocol* proto, const  ::actor::cpp2::UpdateActorRegistry* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorRegistry>::read(Protocol* proto,   ::actor::cpp2::UpdateActorRegistry* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorRegistry>::serializedSize(Protocol* proto, const  ::actor::cpp2::UpdateActorRegistry* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorRegistry>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::UpdateActorRegistry* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class UpdateActorInfo : private boost::totally_ordered<UpdateActorInfo> {
 public:

  UpdateActorInfo() {}
  // FragileConstructor for use in initialization lists only

  UpdateActorInfo(apache::thrift::FragileConstructor,  ::actor::cpp2::ActorInfo info__arg) :
      info(std::move(info__arg)) {}

  UpdateActorInfo(UpdateActorInfo&&) = default;

  UpdateActorInfo(const UpdateActorInfo&) = default;

  UpdateActorInfo& operator=(UpdateActorInfo&&) = default;

  UpdateActorInfo& operator=(const UpdateActorInfo&) = default;
  void __clear();

  virtual ~UpdateActorInfo() throw() {}

   ::actor::cpp2::ActorInfo info;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      info = false;
    }

    bool info;
  } __isset;
  bool operator==(const UpdateActorInfo& rhs) const;
  bool operator < (const UpdateActorInfo& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(UpdateActorInfo& a, UpdateActorInfo& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::UpdateActorInfo>::clear( ::actor::cpp2::UpdateActorInfo* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorInfo>::write(Protocol* proto, const  ::actor::cpp2::UpdateActorInfo* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorInfo>::read(Protocol* proto,   ::actor::cpp2::UpdateActorInfo* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorInfo>::serializedSize(Protocol* proto, const  ::actor::cpp2::UpdateActorInfo* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::UpdateActorInfo>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::UpdateActorInfo* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class RegisterException : private boost::totally_ordered<RegisterException>, public apache::thrift::TException {
 public:

  RegisterException() {}
  // FragileConstructor for use in initialization lists only

  RegisterException(apache::thrift::FragileConstructor) {}

  RegisterException(RegisterException&&) = default;

  RegisterException(const RegisterException&) = default;

  RegisterException& operator=(RegisterException&&) = default;

  RegisterException& operator=(const RegisterException&) = default;

  virtual ~RegisterException() throw() {}

  bool operator==(const RegisterException& /* rhs */) const;

  bool operator < (const RegisterException& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  virtual const char* what() const throw() {
    return " ::actor::cpp2::RegisterException";
  }
};

void swap(RegisterException& a, RegisterException& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::RegisterException>::write(Protocol* proto, const  ::actor::cpp2::RegisterException* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::RegisterException>::read(Protocol* proto,   ::actor::cpp2::RegisterException* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::RegisterException>::serializedSize(Protocol* proto, const  ::actor::cpp2::RegisterException* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::RegisterException>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::RegisterException* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GroupAddVolume : private boost::totally_ordered<GroupAddVolume> {
 public:

  GroupAddVolume() :
      volumeId(0) {}
  // FragileConstructor for use in initialization lists only

  GroupAddVolume(apache::thrift::FragileConstructor,  ::actor::cpp2::ReplicaGroupInfo replicaInfo__arg, int64_t volumeId__arg, std::string volumeName__arg) :
      replicaInfo(std::move(replicaInfo__arg)),
      volumeId(std::move(volumeId__arg)),
      volumeName(std::move(volumeName__arg)) {}

  GroupAddVolume(GroupAddVolume&&) = default;

  GroupAddVolume(const GroupAddVolume&) = default;

  GroupAddVolume& operator=(GroupAddVolume&&) = default;

  GroupAddVolume& operator=(const GroupAddVolume&) = default;
  void __clear();

  virtual ~GroupAddVolume() throw() {}

   ::actor::cpp2::ReplicaGroupInfo replicaInfo;
  int64_t volumeId;
  std::string volumeName;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      replicaInfo = false;
      volumeId = false;
      volumeName = false;
    }

    bool replicaInfo;
    bool volumeId;
    bool volumeName;
  } __isset;
  bool operator==(const GroupAddVolume& rhs) const;
  bool operator < (const GroupAddVolume& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GroupAddVolume& a, GroupAddVolume& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::actor::cpp2::GroupAddVolume>::clear( ::actor::cpp2::GroupAddVolume* obj) {
  return obj->__clear();
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupAddVolume>::write(Protocol* proto, const  ::actor::cpp2::GroupAddVolume* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupAddVolume>::read(Protocol* proto,   ::actor::cpp2::GroupAddVolume* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupAddVolume>::serializedSize(Protocol* proto, const  ::actor::cpp2::GroupAddVolume* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupAddVolume>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GroupAddVolume* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GroupPutObject : private boost::totally_ordered<GroupPutObject> {
 public:

  GroupPutObject() {}
  // FragileConstructor for use in initialization lists only

  GroupPutObject(apache::thrift::FragileConstructor) {}

  GroupPutObject(GroupPutObject&&) = default;

  GroupPutObject(const GroupPutObject&) = default;

  GroupPutObject& operator=(GroupPutObject&&) = default;

  GroupPutObject& operator=(const GroupPutObject&) = default;

  virtual ~GroupPutObject() throw() {}

  bool operator==(const GroupPutObject& /* rhs */) const;

  bool operator < (const GroupPutObject& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GroupPutObject& a, GroupPutObject& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObject>::write(Protocol* proto, const  ::actor::cpp2::GroupPutObject* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObject>::read(Protocol* proto,   ::actor::cpp2::GroupPutObject* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObject>::serializedSize(Protocol* proto, const  ::actor::cpp2::GroupPutObject* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObject>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GroupPutObject* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GroupPutObjectResp : private boost::totally_ordered<GroupPutObjectResp> {
 public:

  GroupPutObjectResp() {}
  // FragileConstructor for use in initialization lists only

  GroupPutObjectResp(apache::thrift::FragileConstructor) {}

  GroupPutObjectResp(GroupPutObjectResp&&) = default;

  GroupPutObjectResp(const GroupPutObjectResp&) = default;

  GroupPutObjectResp& operator=(GroupPutObjectResp&&) = default;

  GroupPutObjectResp& operator=(const GroupPutObjectResp&) = default;

  virtual ~GroupPutObjectResp() throw() {}

  bool operator==(const GroupPutObjectResp& /* rhs */) const;

  bool operator < (const GroupPutObjectResp& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GroupPutObjectResp& a, GroupPutObjectResp& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObjectResp>::write(Protocol* proto, const  ::actor::cpp2::GroupPutObjectResp* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObjectResp>::read(Protocol* proto,   ::actor::cpp2::GroupPutObjectResp* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObjectResp>::serializedSize(Protocol* proto, const  ::actor::cpp2::GroupPutObjectResp* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupPutObjectResp>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GroupPutObjectResp* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GroupGetObject : private boost::totally_ordered<GroupGetObject> {
 public:

  GroupGetObject() {}
  // FragileConstructor for use in initialization lists only

  GroupGetObject(apache::thrift::FragileConstructor) {}

  GroupGetObject(GroupGetObject&&) = default;

  GroupGetObject(const GroupGetObject&) = default;

  GroupGetObject& operator=(GroupGetObject&&) = default;

  GroupGetObject& operator=(const GroupGetObject&) = default;

  virtual ~GroupGetObject() throw() {}

  bool operator==(const GroupGetObject& /* rhs */) const;

  bool operator < (const GroupGetObject& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GroupGetObject& a, GroupGetObject& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObject>::write(Protocol* proto, const  ::actor::cpp2::GroupGetObject* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObject>::read(Protocol* proto,   ::actor::cpp2::GroupGetObject* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObject>::serializedSize(Protocol* proto, const  ::actor::cpp2::GroupGetObject* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObject>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GroupGetObject* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

class GroupGetObjectResp : private boost::totally_ordered<GroupGetObjectResp> {
 public:

  GroupGetObjectResp() {}
  // FragileConstructor for use in initialization lists only

  GroupGetObjectResp(apache::thrift::FragileConstructor) {}

  GroupGetObjectResp(GroupGetObjectResp&&) = default;

  GroupGetObjectResp(const GroupGetObjectResp&) = default;

  GroupGetObjectResp& operator=(GroupGetObjectResp&&) = default;

  GroupGetObjectResp& operator=(const GroupGetObjectResp&) = default;

  virtual ~GroupGetObjectResp() throw() {}

  bool operator==(const GroupGetObjectResp& /* rhs */) const;

  bool operator < (const GroupGetObjectResp& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(GroupGetObjectResp& a, GroupGetObjectResp& b);

}} // actor::cpp2
namespace apache { namespace thrift {

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObjectResp>::write(Protocol* proto, const  ::actor::cpp2::GroupGetObjectResp* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObjectResp>::read(Protocol* proto,   ::actor::cpp2::GroupGetObjectResp* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObjectResp>::serializedSize(Protocol* proto, const  ::actor::cpp2::GroupGetObjectResp* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::actor::cpp2::GroupGetObjectResp>::serializedSizeZC(Protocol* proto, const  ::actor::cpp2::GroupGetObjectResp* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace actor { namespace cpp2 {

}} // actor::cpp2